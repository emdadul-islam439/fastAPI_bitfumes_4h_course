## FastApi read file line by line. So, position the functions 'carefully'
    * place "@app.get('/blog/unpublished')" before "@app.get('/blog/{id}')"
        -> if the 'id' variable is 'int', then 'unpublished' will be 'un-acceptable' becasue of being 'string'


## By the use of 'Optional', we can reduce the number of functions to call 
    * used optional query-parameter into the index(...) functions  
        -> because of this, we have able to remove two redundant function call


## for debugging purposes, you can run the file in different port
    * import uvicorn
    * type 'python3 main.py' to run
    * can output as the other methods
    -> if __name__ == "__main__":
            uvicorn.run(app, host = "127.0.0.1", port = 9000)


## you can install all the dependancies from a text file:
    -> requirements.txt file contains all the dependancies' names
        -uvicorn
        -fastapi
    -> in the terminal, write "pip install -r requirements.txt", that's it!! installation will be started


## you can check the lates DB info:
    -> install "Table Plus" from their website
    -> select "SQLite" databaste, Give a name, select the .db file from computer
    -> press "Connect", That's it!


-------------------- Starting DB integration --------------------------

## create a folder named -> "blog" and add->
    -> "__init__.py" empty file
    -> "main.py" file. we well write code in it 
    -> create a file "requirements.txt" and write all the dependancy names
    -> create virtual environment (if not running it already)
    -> install all the dependancies from requirements.txt file from command line
        - "pip install -r requirements.txt"


## Start Writing into the 'blog/main.py' file
    -> write a simple 'post' api 
        - imported 'fastapi' and 'pydantic' 
        - wrote a 'create(request: Blog)' function


## Storing first ROW into the DB:
    * Create schemas.py file
        -> transfer the Blog class to this file
    * Create database.py file
        -> follow these links' steps:
            - https://fastapi.tiangolo.com/tutorial/sql-databases/
            - https://docs.sqlalchemy.org/en/13/orm/tutorial.html [engine, session, etc.]
    * Create models.py file
        -> add a base (data) class named Blog
        -> define id, title, body variables related to blogs info
    * Write "Creating DB" related codes
        -> models.....create_all()
        -> add new data into the DB
        -> call db related different functions
            -db.add(...)
            -db.commit()
            -db.refresh(..)
    * finally run the code. That's it!


## add Get API:
    -> use db.query(..) method
    -> sometimes have to use db.query(....).filter(...) method
    -> use type into the query(...) method
        - query(models.Blog)
    -> use type and properties into the filter(...) method
        - filter(models.Blog.id == ....)


## Use status_code and HTTPException to return custom details-codes
    -> from fastapi import status, Response, HTTPException
    -> @app.get("/blog", status_code=status.HTTP_200_OK)
    -> if not blog:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail= f"Blog no. {id} not found!")
        #Or, 
        # response.status_code = status.HTTP_404_NOT_FOUND #from fastapi import Response
        # return { "detail" : f"Blog no. {id} not found!" }


## Delete and Update (delete and put):
    -> for delete()
        - use "HTTP_204_NO_CONTENT" as default request_code
        - use ".delete(synchronize_session=False)" after "db.query(models.Blog).filter(models.Blog.id == id)"
    -> for put()
        - use "HTTP_202_ACCEPTED" as default request_code
        - use ".blog.update(updated_request.dict())" after "db.query(models.Blog).filter(models.Blog.id == id)"
        - don't use any comma after the last value of the json file
            -> use {"body": "1st updated body"} instead of {"body": "1st updated body",}


## Creating Response Model 
    -> suppose, you're returning 'blog details'. In the normal way, you will return 'title', 'id' and 'body'
    -> But, if you just want to show 'title' and 'body', and try to HIDE the 'id', then use a RESPONSE Model
    -> HOW CAN MAKE/USE:
        - in the schemas.py create class: class ShowBlog()
        - inside ShowBlog() class, create another class name 'Config', and make orm_mode=True
            : class Config():
                orm_mode = True
        - create the variables related to showing the details: title: str, body: str
            : if you don't use any variable, empty dict() will be returned
        - inside "@app.get(...)", use response_model =schemas.ShowBlog
        - if you want to return a list, use "List[...]"
            : from typing import List
            : response_model = List[schemas.ShowBlog]


## Create User:
    -> Created User Table
        - in schemas.py file, created a class named "User"
        - in models.py file, created a class named "User" and given: "__tablename__ = 'users'"
    -> created PUT API using "@app.put(...)" with "/user" end-point and "status_code=status.HTTP_201_CREATED"

## Show User:
    -> Created "response_model"
        - in schemas.py file, created a class named "ShowUser" with:
            ** Class Config: 
                    orm_mode = True
    -> created GET API using "app.get(...)" with end-point, status_code and "response_model = schemas.ShowUser"


## Hash password:
    -> install 'passlib[bcrypt]' library with the requirements.txt file
    -> import "from passlib.context import CryptContext"
    -> create a variable: 
        -pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
    -> call 'pwd_context.hash(...)' to hash the password: 
        -hashed_password = pwd_context.hash(request.password)

## Using 'tags':
    -> for dividing different API into different sections, use 'tags'
        - inside the "@app.get/put/delete/post(...)", use "tags=[...]"
            * Example: "@app.get('/blogs', status_code=---, tags=['Blogs'])
        - That's it!